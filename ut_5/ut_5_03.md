# U.T. 5 A-Frame
- [U.T. 5 A-Frame](#ut-5-a-frame)
  - [El framework en profundidad](#el-framework-en-profundidad)
    - [Instalación y configuración incial](#instalación-y-configuración-incial)
      - [Uso de sitos externos](#uso-de-sitos-externos)
      - [Uso de nuestro propio servidor HTTP / HTTPS](#uso-de-nuestro-propio-servidor-http--https)
    - [Primeros pasos en la creación de una escena](#primeros-pasos-en-la-creación-de-una-escena)
    - [El sistema de componentes - entidades](#el-sistema-de-componentes---entidades)
      - [Beneficios de la arquitectura ECS:](#beneficios-de-la-arquitectura-ecs)
      - [A-Frame tiene un API que representa cada parte de ECS:](#a-frame-tiene-un-api-que-representa-cada-parte-de-ecs)
      - [Syntax](#syntax)
      - [Composition](#composition)
      - [Declarative DOM-Based ECS](#declarative-dom-based-ecs)
      - [Component-Based Development](#component-based-development)
      - [Higher-Order Components](#higher-order-components)
      - [Community Component Ecosystem](#community-component-ecosystem)
      - [Entidades](#entidades)
      - [Componentes](#componentes)


## El framework en profundidad
> https://jgbarah.github.io/aframe-playground/

### Instalación y configuración incial
En general es preferible acceder a los fuentes a través de un servidor web, y en concreto que tenga configurada una conexión segura (https) ya que algunas funcionalidades solo son accesibles a través de dicho protocolo.

A continuación crearemos el fichero html en el que cargaremos la librería aframe desde un recurso propio o externo, a través de la etiqueta \<script>

#### Uso de sitos externos
- GitHub. Se puede usar GitHub como servidor a través de sus repositorios. si el repositorio es algo del tipo https://github.com/user/repo se accederá vía http seguro desde https://user.github.io/repo.

- GitLab. Es similar a Github. Si el repositorio es https://gitlab.com/user/repo accederemos vía HTTPS con https://user.gitlab.io/repo.
  
#### Uso de nuestro propio servidor HTTP / HTTPS
- webpack-dev-server. https://webpack.js.org/configuration/dev-server/.
- XAMPP. XAMPP es una distribución de Apache completamente gratuita y fácil de instalar que contiene MariaDB, PHP y Perl. El paquete de instalación de XAMPP ha sido diseñado para ser increíblemente fácil de instalar y usar. https://www.apachefriends.org/es/index.html
  
### Primeros pasos en la creación de una escena
 Crearemos una escena con una caja, una esfera, un cilindro encima de un planlo, con el cielo en gris. Se utilizarán algunas imágenes para que se visualicen dentro de cada objeto.

Para poder ejecutar dicha aplicación, es necesario tener la siguiente estructura de directorios u ficheros en el directorio correspondiente del servidor (generalmente httpd en XAMP).

    assets
    |-js
      |- aframe.min.js
    |- imgs
      |- bands.jpg
      |- molinos-bw.jpg
      |- window.jpg
      |- soil.jpg
    03
    |- 01.html

Una aplicación A-Frame puede ser desarrollada desde un fichero HTML plano sin instalar nada. La mejor manera de probar A-Frame es crear dentro de https un fichero html y dentro de la etiqueta \<head> cargar la librería A-Frame bien como un cdn externo o como recurso propio.

    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>

    o

    <script src="../assets/js/aframe.min.js"></script>

**01.html**
El primer paso es cargar la librería desde un recurso propio o externo, a través de la etiqueta \<script>.
A continuación la creación de la escena es simple, dentro del \<body>, se crea una etiqueta \<a-scene> con el contenido de la misma. Cada objeto es una etiqueta distinta y cada etiqueta establece las propiedades necesarias, entre las que destacan la posicion, la rotación, la escala y una imagen a mostrar dentro de la forma.

*Fuentes*

>     <!DOCTYPE html>
>     <html>
>       <head>
>         <meta charset="UTF-8">
>         <!--    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script> -->
>         <script src="../assets/js/aframe.min.js"></script>
>       </head>
>       <body>
>         <a-scene background="color: grey">
>           <a-box position="3.5 1 -3" rotation="0 90 0" scale="2 2 2" src="../assets/imgs/molinos-bw.jpg"></a-box> 
>           <a-sphere position="0 1.25 -5" radius="1.25" src="../assets/imgs/soil.jpg"></a-sphere>
>           <a-cylinder position="1 1.25 -3" radius="0.5" height="2.5" src="../assets/imgs/bands.jpg"></a-cylinder>
>           <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" src="../assets/imgs/window.jpg"></a-plane>
>         </a-scene>
>       </body>
>     </html>


**02.html**
En este ejemplo hemos cambiado la imágen de la esferan proyectándose 360º en vez de ser una textura, para esto se hace una fotografía con una cámara de 360º. 
Se ha añadido una animación en la caja, se mueve repetidamente ademante y atrás.

    animation="property: position; to: 5.5 1 -5;
                            dir: alternate; dur: 4000;
                            loop: true"

Se ponen varias luces para una mejor iluminación y un color de fondo.

    <a-light type="ambient" color="grey"></a-light>
    <a-light type="point" intensity="2" position="-2 2 4"></a-light>

También se reestructuran los recursos, agrupándolos ahora en una etiqueta <a-assets> todos en vez de estar dispersos por cada elmento. Esto implica que la propiedad **src** cambia de una url a un id (#nombre). La ventaja es que se hace una carga inicial de todos los recursos sin interferiz con la escena.

*Fuentes*

>     <body>
>       <a-scene background="color: grey">
>          <a-assets>
>            <img id="molinos" src="../assets/imgs/molinos-bw.jpg">
>            <img id="soil" src="../assets/imgs/soil.jpg">
>            <img id="bands" src="../assets/imgs/bands.jpg">
>            <img id="plaza-360" src="../assets/imgs/plaza-360.jpg">
>          </a-assets>
>          <a-box position="3.5 1 -3" rotation="0 90 0" scale="2 2 2"    
>                src="#molinos"
>                animation="property: position; to: 5.5 1 -5;
>                            dir: alternate; dur: 4000;
>                            loop: true">
>          </a-box>
>          <a-sphere position="0 1.25 -5" radius="1.25"  src="#plaza-360"></a-sphere>
>          <a-cylinder position="1 1.25 -3" radius="0.5" height="2.5" src="#bands"></a-cylinder>
>          <a-plane position="0 0 -4" rotation="-90 0 0" width="8" height="4" repeat="4 2" src="#soil"></a-plane>
>           <a-light type="ambient" color="grey"></a-light>
>          <a-light type="point" intensity="2" position="-2 2 4"></a-light>
>        </a-scene>
>     </body>

**03.html**
Dibujar texto en 3D es difícil. En 2D crear texto es una acción básica porque el motor de renderizado está optimizado para ese tipo de trabajo. Pero en 3D tenemos que lidiar con otros problemas. Para poder escribir texto en 3D existen difererentes métodos, entre los que encontramos:
- Texto 3D Text
- Materiales HTML (DOM-to-Canvas-to-Texture)
- Texturas (imágenes)

Añadimos texto a nuestro fichero indicando sus propiedades y la fuente que deseamos usar, en esta caso descargada en nuestros recursos. 

    <a-text value="Just a simple test" color="red"
          position="-3.5 0.5 -2" rotation="-45 30 0" scale="2.5 2.5 2.5"
                font="../assets/fonts/Roboto-msdf.json"></a-text>

También se añade una cámara a la escena, estableciendo el punto de vista desde el que el actor la visualizará. Para poder crearla hay que encerrarla dentro de una entidad para poder sobrescribir la posición y la rotación.

    <a-entity position="-3 2 1" rotation="0 -25 0">
      <a-camera></a-camera>
    </a-entity>

Estas líneas posicionan la cámara 3 unidades a la izquierda, 2 arriba y 1 junto al origen, apuntando 25º hacia la derecha.

*Fuentes*

>      <a-scene background="color: grey">
>        <a-assets>
>          <img id="molinos" src="../assets/imgs/molinos-bw.jpg">
>          <img id="soil" src="../assets/imgs/soil.jpg">
>          <img id="bands" src="../assets/imgs/bands.jpg">
>        </a-assets>
>
>        <a-box position="3.5 1 -3" rotation="0 90 0" scale="2 2 2" src="#molinos"
>              animation="property: position; to: 5.5 1 -5;
>                          dir: alternate; dur: 4000;
>                          loop: true">
>        </a-box>
>        <a-sphere position="-2 1.25 -5" radius="1.25" src="#soil"></a-sphere>
>        <a-cylinder position="1 1.25 -3" radius="0.5" height="2.5" src="#bands"></a-cylinder>-->
>        <a-plane position="0 0 -4" rotation="-90 0 0" width="10" height="4" repeat="4 2" src="#soil"></a-plane>
>        <a-text value="Just a simple test" color="red"
>          position="-3.5 0.5 -2" rotation="-45 30 0" scale="2.5 2.5 2.5"
>                font="../assets/fonts/Roboto-msdf.json"></a-text>
>
>        <a-light type="ambient" color="grey"></a-light>
>        <a-light type="point" intensity="2" position="-2 2 4"></a-light>
>
>        <a-entity position="-3 1 1" rotation="0 -25 0">
>          <a-camera></a-camera>
>        </a-entity>
>      </a-scene>

**04.html**
El siguiente paso añade algo de javascript a la escena modificando el comportamiento de la esfera cuando la señalamos con el cursos, en concreto crece de tamaño. Se hace a crando la etiqueta correspondiente al final del fichero dentro de la escena.

    <script>
      var sphere = document.querySelector('a-sphere');
      sphere.addEventListener('mouseenter', function () {
          sphere.setAttribute('scale', {x: 1.2, y: 1.2, z: 1.2});
      });
      sphere.addEventListener('mouseleave', function () {
          sphere.setAttribute('scale', {x: 1, y: 1, z: 1});
      });
    </script>


Como podemos comprobar es similar a lo que se hace en javascript tradicional a la hora de capturtar eventos en el DOM. El único truco, es que el cursor (círculo) que se añade funcionará como un ratón y será el desencadenate de los diferentes eventos: mouseenter y mouseleave.

Se añade otro tipo de texto a la escena, ahora en un plano.

    <a-entity>
        geometry="primitive: plane; width: 4; height: auto"
        position="0 3 -3"
        material="color: red"
        font="./assets/Roboto-msdf.json"
        text="value: This is another test"></a-entity>


*Fuentes*

>      <a-scene background="color: grey">
>          <a-assets>
>            <img id="molinos" src="../assets/imgs/molinos-bw.jpg">
>            <img id="soil" src="../assets/imgs/soil.jpg">
>            <img id="bands" src="../assets/imgs/bands.jpg">
>          </a-assets>
>
>          <a-box position="3.5 1 -3" rotation="0 90 0" scale="2 2 2"    
>                src="#molinos"
>                animation="property: position; to: 5.5 1 -5;
>                            dir: alternate; dur: 4000;
>                            loop: true">
>          </a-box>
>          <a-sphere position="-2 1.25 -5" radius="1.25" src="#soil"></a-sphere>
>          <a-cylinder position="1 1.25 -3" radius="0.5" height="2.5"  src="#bands"></a-cylinder>
>          <a-plane position="0 0 -4" rotation="-90 0 0" width="10" height="4" repeat="4 2" src="#soil"></a-plane>
>          <a-entity
>            geometry="primitive: plane; width: 4; height: auto"
>            position="0 3 -3"
>            material="color: red"
>            font="./assets/Roboto-msdf.json"
>            text="value: This is another test"></a-entity>
>
>          <a-light type="ambient" color="grey"></a-light>
>          <a-light type="point" intensity="2" position="-2 2 4"></a-light>
>
>          <a-entity position="-3 1 1" rotation="0 -25 0">
>            <a-camera>
>              <a-cursor></a-cursor>
>            </a-camera>
>          </a-entity>
>        </a-scene>
>
>        <script>
>          var sphere = document.querySelector('a-sphere');
>          sphere.addEventListener('mouseenter', function () {
>              sphere.setAttribute('scale', {x: 1.2, y: 1.2, z: 1.2});
>          });
>          sphere.addEventListener('mouseleave', function () {
>              sphere.setAttribute('scale', {x: 1, y: 1, z: 1});
>          });
>        </script>

**05.html**
Para un móvil, o un entrono de AR real hay que añadir algunas configuraciones más. En concreto se elimina el fondo.

>     <a-scene>

**06.html**
En vez de usar el cursor de posición (círculo), podemos usar el ratón, lo únco que tenemos que cambiar el la propiedad rayOrigin:

>      <a-entity position="-3 1 1" rotation="0 -25 0">
>        <a-camera cursor="rayOrigin:mouse">
>        </a-camera>
>      </a-entity>

**07.html**
Para trabajar correctamente con los periféricos de VR (Gafas y mandos) hay que añadir los controles de moviento. Para este fin, hay que utilizar otra librería más (A-frame-extras) que podemos descargar de https://github.com/n5ro/aframe-extras o https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/). Enconraremos controles de visión, controles láser, etc.

*Fuentes*

>     <!DOCTYPE html>
>     <html>
>      <head>
>        <meta charset="UTF-8">
>        <!--    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script> -->
>        <script src="../assets/js/aframe.min.js"></script>
>        <script src="//cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
>      </head>
>      <body>
>        <a-scene background="color: grey">
>          <a-assets>
>            <img id="molinos" src="../assets/imgs/molinos-bw.jpg">
>            <img id="soil" src="../assets/imgs/soil.jpg">
>            <img id="bands" src="../assets/imgs/bands.jpg">
>          </a-assets>
>
>          <a-box position="3.5 1 -3" rotation="0 90 0" scale="2 2 2" src="#molinos"
>                animation="property: position; to: 5.5 1 -5;
>                            dir: alternate; dur: 4000;
>                            loop: true">
>          </a-box>
>          <a-sphere position="-2 1.25 -5" radius="1.25" src="#soil"></a-sphere>
>          <a-cylinder position="1 1.25 -3" radius="0.5" height="2.5"
>                      src="#bands"></a-cylinder>
>          <a-plane position="0 0 -4" rotation="-90 0 0" width="10" height="4"
>                  repeat="4 2" src="#soil"></a-plane>
>          <a-entity
>            geometry="primitive: plane; width: 4; height: auto"
>            position="0 3 -3"
>            material="color: red"
>            font="./assets/Roboto-msdf.json"
>            text="value: This is another test"></a-entity>
>
>          <a-light type="ambient" color="grey"></a-light>
>          <a-light type="point" intensity="2" position="-2 2 4"></a-light>
>
>          <a-entity movement-controls="fly: true" position="-3 1 1" rotation="0 -25 0">
>            <a-entity camera position="0 1.6 0" look-controls></a-entity>
>            <a-entity cursor="rayOrigin:mouse"></a-entity>
>            <a-entity laser-controls="hand: right"></a-entity>
>          </a-entity>
>
>        </a-scene>
>
>        <script>
>        var sphere = document.querySelector('a-sphere');
>        sphere.addEventListener('mouseenter', function () {
>          sphere.setAttribute('scale', {x: 1.2, y: 1.2, z: 1.2});
>        });
>        sphere.addEventListener('mouseleave', function () {
>          sphere.setAttribute('scale', {x: 1, y: 1, z: 1});
>        });
>        </script>
>      </body>
>     </html>

**08.html**
La equivalencia entre primitivas y entidades no es exacta. En este ejemplo vamos a crear una imagen curvada. Podemos hacer este efecto partiendo de una primitiva imagen-curva, un cilindro o una entidad usando un cilindro. 
 
    <a-curvedimage height="6.0" radius="5" theta-length="70"
          position="0 3 -4" rotation="0 60 0" src="#window"></a-curvedimage>

 Añadimos algo de niebla. Para configurar la niebla hay que establecer el modelo, en este caso linea, que funciona bien si se seleccionan los valores de lejos y cerca adecuadamente. Cuando usamos niebla, se puede usar el elemento sky ya que este es una acumulación de niebla.
 
    <a-scene fog="type: linear; color: lightgrey; far: 10; near: 1" stats>

>*Probar a alejarse de la escena para ver el efecto de la niebla.*

*Fuentes*

>      <a-scene fog="type: linear; color: lightgrey; far: 10; near: 1" stats>
>        <a-assets>
>          <img id="soil" src="../assets/imgs/soil.jpg">
>          <img id="bands" src="../assets/imgs/bands.jpg">
>          <img id="window" src="../assets/imgs/window.jpg">
>        </a-assets>
>
>        <a-entity
>            geometry="primitive: cylinder; height: 6.0; radius: 5;
>              theta-length: 70; open-ended: true"
>            position="0 3 -4"
>            rotation="0 220 0"
>            material="src: #window; side: double"></a-entity>
>        <a-cylinder height="6.0" radius="5" theta-length="70" open-ended="true"
>          side="double" position="0 3 -4" rotation="0 140 0"
>          color="red"></a-cylinder>
>        <a-curvedimage height="6.0" radius="5" theta-length="70"
>          position="0 3 -4" rotation="0 60 0" src="#window"></a-curvedimage>
>
>        <a-sphere position="-2 1.25 -5" radius="1.25" src="#soil"></a-sphere>
>        <a-cylinder position="1 1.25 -3" radius="0.5" height="2.5" src="#bands"></a-cylinder>
>        <a-plane position="0 0 -4" rotation="-90 0 0" width="15" height="6" repeat="4 2" src="#soil"></a-plane>
>
>        <a-light type="ambient" color="grey"></a-light>
>        <a-light type="point" intensity="2" position="-2 2 4"></a-light>
>      </a-scene>

### El sistema de componentes - entidades
>https://aframe.io/docs/1.3.0/introduction/entity-component-system.html

A-Frame es un framwwork de three.js basado en una arquitectura (ECS). La arquitectura ECS es un patrón de diseño deseable en el diseño 3D y en el desarrollo de videojuesgos ya que permite la composición sobre el principio de herencia de la POO.

#### Beneficios de la arquitectura ECS:

- Hay una mayor flexibilidad cuando se definen objetos mezclándolos y reusando partes.
- Elimina el problema de largas cadenas de herencia con complejas funcionalidades interconectadas.
- Proporcionaa un diseño simple, desacoplando, encapsulando, modularizando y reusando elementos.
- Es la manera más escalable de construir una aplicación en términos de complejidad.
- Proporcionan una arquitectura para el desarrollo en 3D y VR.
- Permiote extender la aplicación con nuevas características (y compartirlas como componentes de la comunidad)

En la web, organizamos los elementos estáticos en una jerarquía. En el diseño 3D y VR es diferente; hay infinitos tipos de objetos con comportamientos potencialmente ilimitados. ECS proporcionanm un patron manejable de desarrollo para construir ese tipo de objetos.


#### A-Frame tiene un API que representa cada parte de ECS:
- Las Entidades se representa con la etiqeuta <a-entity>.
- Los Componentes se representan como atributos de la etiqueta <a-entity>. Por debajo, los componentes son objetos que contienen un esquema, manejadores del ciclo de vida y métodos. Los componentes se registran a través de la función del API:**AFRAME.registerComponent(name, definition)**.
- Los sistemas se representan como atributos de la etiqueta <a-scene>. Los sistemas son similares a los componentes en la definición. Los Sistemas se registran a través de la función del API: **AFRAME.registerSystem (name, definition)**.

#### Syntax
Creamos una <a-entity> y enlazamos los componentes como atributos HTML. La mayoría de componentes tienen múltiples propiedades que establecemos con una sintáxix similar a los estilos CSS. Esta sintáxis separa a través de los dos puntos (:) el nombre de la propiedad de su valor, y cada propiedad es separada mediante el punto y coma (;) de la siguiente:

    <a-entity ${componentName}="${propertyName1}: ${propertyValue1}; ${propertyName2}: ${propertyValue2}">

En el ejemplo siguiente, tenemos <a-entity> unida al componente *geometry*, *material*, *light*, and *position* con varias propiedades y sus valores (primitive: sphere; radius: 1.5)

    <a-entity geometry="primitive: sphere; radius: 1.5"
              light="type: point; color: white; intensity: 2"
              material="color: white; shader: flat; src: glow.jpg"
              position="0 0 -5"></a-entity>

#### Composition
From there, we could attach more components to add additional appearance, behavior, or functionality (e.g., physics). Or we could update the component values to configure the entity (either declaratively or through .setAttribute).          

A common type of entity to compose from multiple components are the player’s hands in VR. The player’s hands can have many components: appearance, gestures, behaviors, interactivity with other objects.

We plug in components into a hand entity to provide it behavior as if we were attaching superpowers or augmentations for VR! Each of the components below have no knowledge of each other, but can be combined to define a complex entity:

    <a-entity
      tracked-controls  <!-- Hook into the Gamepad API for pose. -->
      vive-controls  <!-- Vive button mappings. -->
      oculus-touch-controls  <!-- Oculus button mappings. -->
      hand-controls  <!-- Appearance (model), gestures, and events. -->
      laser-controls <!-- Laser to interact with menus and UI. -->
      sphere-collider  <!-- Listen when hand is in contact with an object. -->
      grab  <!-- Provide ability to grab objects. -->
      throw <!-- Provide ability to throw objects. -->
      event-set="_event: grabstart; visible: false"  <!-- Hide hand when grabbing object. -->
      event-set="_event: grabend; visible: true"  <!-- Show hand when no longer grabbing object. -->

#### Declarative DOM-Based ECS
A-Frame takes ECS to another level by making it declarative and based on the DOM. Traditionally, ECS-based engines would create entities, attach components, update components, remove components all through code. But A-Frame has HTML and the DOM which makes ECS ergonomic and resolves many of its weaknesses. Below are abilities that the DOM provides for ECS:

- Referencing Other Entities with Query Selectors: The DOM provides a powerful query selector system which lets us query the scene graph and select an entity or entities that match a condition. We can get references to entities by IDs, classes, or data attributes. Because A-Frame is based on HTML, we can use query selectors out of the box. document.querySelector('#player').
- Decoupled Cross-Entity Communication with Events: The DOM provides the ability to listen to and emit events. This provides a publish-subscribe communication system between entities. Components don’t have to know about each other, they can just emit an event (which could bubble up), and other components can listen to those events without calling each other. ball.emit('collided').
- APIs for Lifecycle Management with DOM APIs: The DOM provides APIs to update HTML elements and the tree including .setAttribute, .removeAttribute, .createElement, and .removeChild. These can be used as is just like in normal web development.
Entity-Filtering with Attribute Selectors: The DOM provides attribute selectors which allows us to query for an entity or entities that have or don’t have certain HTML attributes. This means we can ask for entities that have or don’t have a certain set of components. document.querySelector('[enemy]:not([alive])').
- Declarativeness: Lastly, the DOM provides HTML. A-Frame bridges between ECS and HTML making an already clean pattern declarative, readable, and copy-and-pasteable.

#### Component-Based Development
For building VR applications, we recommend placing all application code within components (and systems). An ideal A-Frame codebase consists purely of modular, encapsulated, and decoupled components. These components can be unit tested in isolation or alongside other components.

When an application is created solely with components, all parts of its codebase become reusable! Components can be shared for other developers to use or we can reuse them in our other projects. Or the components can be forked and modified to adapt to other use cases.

A simple ECS codebase might be structured like:

    index.html
    components/
      ball.js
      collidable.js
      grabbable.js
      enemy.js
      scoreboard.js
      throwable.js

#### Higher-Order Components
Components can set other components on the entity, making them a higher-order or higher-level component in abstraction.

For example, the cursor component sets and builds on top of the raycaster component. Or the hand-controls component sets and builds on top of the vive-controls component and oculus-touch-controls component which in turn build on top of the tracked-controls component.

#### Community Component Ecosystem
Components can be shared into the A-Frame ecosystem for the community to use. The wonderful thing about A-Frame’s ECS is extensibility. An experienced developer can develop a physics system or graphics shader components, and an novice developer can take those components and use them in their scene from HTML just by dropping in a \<script>
tag. We can use powerful published components without having to touch JavaScript.

#### Entidades
>https://aframe.io/docs/1.3.0/core/entity.html
 
A-Frame represents an entity via the <a-entity> element. As defined in the entity-component-system pattern, entities are placeholder objects to which we plug in components to provide them appearance, behavior, and functionality.

In A-Frame, entities are inherently attached with the position, rotation, and scale components.

**Example**
Consider the entity below. By itself, it has no appearance, behavior, or functionality. It does nothing:

    <a-entity>

We can attach components to it to make it render something or do something. To give it shape and appearance, we can attach the geometry and material components:

    <a-entity geometry="primitive: box" material="color: red">

Or to make it emit light, we can further attach the light component:

    <a-entity geometry="primitive: box" material="color: red"
          light="type: point; intensity: 2.0">
**Retrieving an Entity**
We can simply retrieve an entity using DOM APIs.

    <a-entity id="mario"></a-entity>  
    var el = document.querySelector('#mario');

Once we have an entity, we have access to its properties and methods

#### Componentes
> https://aframe.io/docs/1.3.0/core/component.html

In the entity-component-system pattern, a component is a reusable and modular chunk of data that we plug into an entity to add appearance, behavior, and/or functionality.

In A-Frame, components modify entities which are 3D objects in the scene. We mix and compose components together to build complex objects. They let us encapsulate three.js and JavaScript code into modules that we can use declaratively from HTML.

As an abstract analogy, if we define a smartphone as an entity, we might use components to give it appearance (color, shape), to define its behavior (vibrate when called, shut down on low battery), or to add functionality (camera, screen).

Components are roughly analogous to CSS. Like how CSS rules modify the appearance of elements, component properties modify the appearance, behavior, and functionality of entities.

**Component HTML Form**
A component holds a bucket of data in the form of one or more component properties. Components use this data to modify entities. Consider an engine component, we might define properties such as horsepower or cylinders.

HTML attributes represent component names and the value of those attributes represent component data.

**Single-Property Component**
If a component is a single-property component, meaning its data consists of a single value, then in HTML, the component value looks like a normal HTML attribute:

    <!-- `position` is the name of the position component. -->
    <!-- `1 2 3` is the data of the position component. -->
    <a-entity position="1 2 3"></a-entity>

**Multi-Property Component**
If a component is a multi-property component, meaning the data consists of multiple properties and values, then in HTML, the component value resembles inline CSS styles:

    <!-- `light` is the name of the light component. -->
    <!-- The `type` property of the light is set to `point`. -->
    <!-- The `color` property of the light is set to `crimson`. -->
    <a-entity light="type: point; color: crimson"></a-entity>

**Register a Component**
AFRAME.registerComponent (name, definition)
Register an A-Frame component. We must register components before we use them anywhere in <a-scene>. Meaning from an HTML file, components should come in order before <a-scene>.

{string} name - Component name. The component’s public API as represented through an HTML attribute name.
{Object} definition - Component definition. Contains schema and lifecycle handler methods.

    // Registering component in foo-component.js
    AFRAME.registerComponent('foo', {
      schema: {},
      init: function () {},
      update: function () {},
      tick: function () {},
      remove: function () {},
      pause: function () {},
      play: function () {}
    });
    <!-- Usage of `foo` component. -->
    <html>
      <head>
        <script src="aframe.min.js"></script>
        <script src="foo-component.js"></script>
      </head>
      <body>
        <a-scene>
          <a-entity foo></a-entity>
        </a-scene>
      </body>
    </html>

**Schema**
The schema is an object that defines and describes the property or properties of the component. The schema’s keys are the names of the property, and the schema’s values define the types and values of the property (in case of a multi-property component):

    AFRAME.registerComponent('bar', {
      schema: {
        color: {default: '#FFF'},
        size: {type: 'int', default: 5}
      }
    }
    <a-scene>
      <a-entity bar="color: red; size: 20"></a-entity>
    </a-scene>

---
[Siguiente](ut_5_04.md)
