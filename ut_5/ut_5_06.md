# U.T. 5 A-Frame
- [U.T. 5 A-Frame](#ut-5-a-frame)
  - [El framework en profundidad](#el-framework-en-profundidad)
    - [Seleccionando objetos](#seleccionando-objetos)
      - [Raising events with the mouse](#raising-events-with-the-mouse)
      - [Supporting controls of VR devices](#supporting-controls-of-vr-devices)
      - [Uso del movimiento de cámara en dispositivos VR](#uso-del-movimiento-de-cámara-en-dispositivos-vr)
      - [Gestión de eventos con JavaSctip](#gestión-de-eventos-con-javasctip)
    - [Uos de JavaSxcript](#uos-de-javasxcript)
    - [JavaScript, Events, DOM APIs](#javascript-events-dom-apis)
      - [Dónde situar el código JavaScript para A-Frame](#dónde-situar-el-código-javascript-para-a-frame)
      - [Accediendo a las entidades mediante el DOM](#accediendo-a-las-entidades-mediante-el-dom)
        - [Con .querySelector()](#con-queryselector)
        - [Con .querySelectorAll()](#con-queryselectorall)
        - [Recorriendo Entidades devueltas por .querySelectorAll()](#recorriendo-entidades-devueltas-por-queryselectorall)
          - [Una nota sobre rendimiento](#una-nota-sobre-rendimiento)
        - [Accediendo a los datos de un conponente con .getAttribute()](#accediendo-a-los-datos-de-un-conponente-con-getattribute)
        - [Modifying the A-Frame Scene Graph](#modifying-the-a-frame-scene-graph)
        - [Modifying an Entity](#modifying-an-entity)
        - [Updating a Component with .setAttribute()](#updating-a-component-with-setattribute)
        - [Removing a Component with .removeAttribute()](#removing-a-component-with-removeattribute)
      - [Events and Event Listeners](#events-and-event-listeners)
        - [Emitting an Event with .emit()](#emitting-an-event-with-emit)
        - [Adding an Event Listener with .addEventListener()](#adding-an-event-listener-with-addeventlistener)
        - [Removing an Event Listener with .removeEventListener()](#removing-an-event-listener-with-removeeventlistener)
        - [Binding Event Listeners](#binding-event-listeners)
      - [Caveats](#caveats)


## El framework en profundidad
https://jgbarah.github.io/aframe-playground/
### Seleccionando objetos
Interactionar con los objetos de una escena no es solo moverse alrededor de ellos, estambién seleccionarlos y realizar acciones. Para ello, tenenmos que usar un mecanimsmo para selecionar el objeto en la escena y entonces desecadenar el evento HTML correspondiente en el elemento. Entonces, el elemento detectará el evento, y actuará acorde. Esta selección y acción normalmente ocurre en la programación del front-end, por lo que será muy familiar a aquellos programadores JavaScript.  

#### Raising events with the mouse
Cuando estamos visualizando al escena en el Desktop, podemos elevar los eventos con el ratón. Es necesario que definiamos un elemento cursor en la escena:

>     <a-scene>
>       <a-entity cursor="rayOrigin:mouse"></a-entity>
>     </a-scene>

El cursor es básicamente un rayo, el cual debe "tocar" algúnobjwto para seleccionarlo. Mientras que estamos usando el ratón, queremos que el rayo se visualice desde el objeto hasta el dónde el ratón apunta, esto es lo que hace precisamente: **rayOrigin:mouse**.

Para poder seleccionar objetos, y crear eventos sobre ellos, tenemos que determinar un manejador que los gestione en los propios objetos. Por ejemplo,k podemos usar el componente animación para que la caja salte cuando se hace clic en ella:

>      <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9" shadow
>        animation="startEvents: click; property: position;
>          from: -1 1.5 -3; to: -1 0.5 -3 dur: 1000">
>      </a-box>

Esto significa: que cuando se haga clic en la caja se realizará una animación desde Y=1.5 hasta Y=0.5 en un segundo. El efecto es el que la caja parece saltart.

También podemos hacer que la esfera creazca cuando hacemos clic en ella (cambiando su escala) y que el cilindro crezca al entrar el ratón en él, y vuelva a su tamaño original cuando salga.

>      <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E" shadow
>        animation="startEvents: click; property: scale;
>          from: 2 2 2; to: 1 1 1; dur: 1000">
>      </a-sphere>
>      <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D" shadow
>        animation__enter="startEvents: mouseenter; property: scale;
>          to: 2 2 2; dur: 1000"
>        animation__leave="startEvents: mouseleave; property: scale;
>          to: 1 1 1; dur: 1000">
>      </a-cylinder>


#### Supporting controls of VR devices
Dar soporte a los controles VR en la escena para seleccionar se realiza a través de dos componentes (para oculus): **oculus-go-controls** para Oculus Go, y **oculus-touch-controls** para Rift, Rift S, Oculus Quest 1 and 2. Hay componentes para otros dispositivos (MagicLeap, Gear, etc). Se gestionarán los eventos correspondientes de los contrles, si están presentes, por lo que podemos añadir todos y solo se crearán eventos para los dispositivos detectados.

Podemos hacer una gestión comnpleta, pero es mejor usar el componente: **laser-controls** que es capaz de gestionar a alto nivel los eventos:

>     <a-entity laser-controls="hand: right"></a-entity>

Esto es todo lo que tenemos que hacer, el resto de la escena es la misma. Si  no eliminamos el componente de ratón también funcionará con la escena.

**Nota: En Oculus no funcionará el movimiento de las gafas a menos que incorporemos el componente correspondiente.**

#### Uso del movimiento de cámara en dispositivos VR
Para hacer uso del movimiento hay que añadir la librería de A-Frame extras y añadir el siguiente código:

>     <a-entity movement-controls="fly: true" position="0 0 0">
>       <a-entity camera position="0 1.6 0" look-controls></a-entity>
>       <a-entity cursor="rayOrigin:mouse"></a-entity>
>       <a-entity laser-controls="hand: right"></a-entity>
>     </a-entity>

El código anterior añade capacidad de movimiento a varios dispositivos, además permitirá la selección de la sección anterior que funcione correctamente.

#### Gestión de eventos con JavaSctip
Podemos escribir código JavaScript para la gestión de los eventos en vez de usar las facilidades de las etiquetas A-Frame. Este mecanismo nos dotará de mucha más flexibilidad para programar el comportamiento que deseemos, pero requiere escribir (y conocer) código 
JavaScript.

En este caso, vamos a crear un nuevo componente que gestione lo que necesitamos. Vamos centrarnos en cómo los eventos se instalan en la inicialización del módulo para el componente, y cómo son levantados.

El manejador JAvaScript tiene que ser incluido antes de la escena, en la cabecera de la página HTML:

>     <script>
>       AFRAME.registerComponent("click-listener", {
>         init: function() {
>           this.el.addEventListener("click", function(e) {
>             console.log(e.target)
>             e.target.setAttribute('scale', {x: 2, y: 2, z: 2});
>             });
>           this.el.addEventListener("mouseenter", function(e) {
>            console.log(e.target)
>             e.target.setAttribute('scale', {x: 1.5, y: 1.5, z: 1.5});
>             });
>           this.el.addEventListener("mouseleave", function(e) {
>             console.log(e.target)
>             e.target.setAttribute('scale', {x: 1, y: 1, z: 1});
>             });
>           }
>       });
>     </script>


En este caso, se definen los manejadores de evento en la función init del comnponente para los eventos: click, mouseenter, y mouseleave, visualizan en la consola información y cambiar la escala.

Una vez definido, hay que enlazar el componente con la entidad, como siempre se hace a través de las etiquetas A-Frame:

>      <a-box event-listener position="-1 0.5 -3" rotation="0 45 0"
>             color="#4CC3D9" shadow></a-box>
>      <a-sphere event-listener position="0 1.25 -5" radius="1.25"
>                color="#EF2D5E" shadow></a-sphere>
>      <a-cylinder event-listener position="1 0.75 -3" radius="0.5"
>                  height="1.5" color="#FFC65D" shadow></a-cylinder>

Podemos ver como el mismo manejador de eventos se puede reutilizar en diferentes entidades ya que hace uso de las variables (e, entidad que ha generado el evento) para realizar su función.


### Uos de JavaSxcript
**14_01.js**

      window.addEventListener('DOMContentLoaded', function() {
          let scene = document.querySelector('a-scene');
          scene.addEventListener('loaded', function () {
              // Box
              // <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
              let box = document.createElement('a-box');
              box.setAttribute('color', 'red');
              box.setAttribute('position', {x: -1, y: 0.5, z: -3});
              box.setAttribute('rotation', {x: 0, y: 45, z: 0});
              box.setAttribute('color', "#4CC3D9");
              scene.appendChild(box); 

              // Sphere
              // <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
              let sphere = document.createElement('a-sphere');
              sphere.setAttribute('position', {x:0, y: 1.25, z: -5});
              sphere.setAttribute('radius', 1.25);
              sphere.setAttribute('color', "#EF2D5E");
              scene.appendChild(sphere);

              // Cylinder
              // <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>

              // Plane
              // <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
          });
      });

Creamos tres elementos de forma dinámica en el momento que cargamos la página, a todo los efectos es como si se hubieran definido en la página html pero nos da la posibilidad de aprender a crear objetos de forma dinámica en nuestra escena.

**14_02.js**

      // Component for injecting some A-Frame entities in a scene

      /* global AFRAME */
      if (typeof AFRAME === 'undefined') {
          throw new Error('Component attempted to register before AFRAME was available.');
      }

      AFRAME.registerComponent('basic-scene', {

          init: function() {
              // Box
              // <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
              let box = document.createElement('a-box');
              box.setAttribute('color', 'red');
              box.setAttribute('position', {x: -1, y: 0.5, z: -3});
              box.setAttribute('rotation', {x: 0, y: 45, z: 0});
              box.setAttribute('color', "#4CC3D9");
              this.el.appendChild(box); 

              // Sphere
              // <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
              let sphere = document.createElement('a-sphere');
              sphere.setAttribute('position', {x:0, y: 1.25, z: -5});
              sphere.setAttribute('radius', 1.25);
              sphere.setAttribute('color', "#EF2D5E");
              this.el.appendChild(sphere);

              // Cylinder
              // <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>

              // Plane
              // <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>

          }
      });

Similar al anterior, en este caso se registra unu nuevo componente que aplicaremos a la entidad .

      <a-scene background="color: grey">
          <a-entity basic-scene></a-entity>
      </a-scene>

**14_03.html**

      // Component for injecting some A-Frame entities in a scene

      /* global AFRAME */
      if (typeof AFRAME === 'undefined') {
          throw new Error('Component attempted to register before AFRAME was available.');
      }

      AFRAME.registerComponent('basic-scene', {

          init: function() {
              // Box
              // <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
              let box = document.createElement('a-box');
              box.setAttribute('color', 'red');
              box.setAttribute('position', {x: -1, y: 0.5, z: -3});
              box.setAttribute('rotation', {x: 0, y: 45, z: 0});
              box.setAttribute('color', "#4CC3D9");
              box.setAttribute('animation', {'startEvents': 'click',
                                            'property': 'position',
                                            'from': {x: -1, y: 1.5, z: -3},
                                            'to': {x: -1, y: 0.5, z: -3},
                                            'dur': 1000});
              this.el.appendChild(box); 

              // Sphere
              // <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
              let sphere = document.createElement('a-sphere');
              sphere.setAttribute('position', {x:0, y: 1.25, z: -5});
              sphere.setAttribute('radius', 1.25);
              sphere.setAttribute('color', "#EF2D5E");
              this.el.appendChild(sphere);
              sphere.addEventListener('click', function() {
                  color = sphere.getAttribute('color');
                  if (color == '#EF2D5E') {
                      sphere.setAttribute('color', 'red');
                  } else {
                      sphere.setAttribute('color', '#EF2D5E');
                  };
          });
              // Cylinder
              // <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>

              // Plane
              // <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>

          }
      });

Añadimos gestión de eventos.

**14_04.js**

      // Component for injecting some A-Frame entities in a scene

      /* global AFRAME */
      if (typeof AFRAME === 'undefined') {
          throw new Error('Component attempted to register before AFRAME was available.');
      }

      AFRAME.registerComponent('globe', {

          init: function() {
              this.el.setAttribute('animation', {'property': 'position',
                                            'to': {x: 0, y: 200, z: 0},
                                            'dur': 100000});
          }
      });

      AFRAME.registerComponent('breakable', {

          init: function() {
              scene = document.querySelector('a-scene');
              el = this.el;
              el.addEventListener('click', function() {
                  scene.removeChild(el)
              });
          }
      });


### JavaScript, Events, DOM APIs
Como A-Frame es sinmplemente HTMKL podemos controlar la escena y sus entidades usando JavaScript y el API del DOM como se hace en la programación front-end tradicional.

Cada elemento en la escena, incluso elementos como <a-box> o <a-sky> son entidades. A-Frame modifica el estándar HTML para añadir nuevas funcionalidades al API del DOM.

#### Dónde situar el código JavaScript para A-Frame
**Nota:** Antes de pasar a las diferentes maneras de escribir código JavaScript para A-Frame, es recomendable que se encapsule todo el código dentro de un nuevo componente, se registre y se asigne a la entidad correspondiente en vez de dispersar el código en ficheros fuente. El registro se tiene que hacer antes de la etiqueta <a-scene>:

>      AFRAME.registerComponent('log', {
>        schema: {type: 'string'},
>
>        init: function () {
>          var stringToLog = this.data;
>          console.log(stringToLog);
>        }
>      });

Después del registro se puede usar:

>     <a-scene log="Hello, Scene!">
>       <a-box log="Hello, Box!"></a-box>
>     </a-scene>

Los componentes encapsulan todo el código necesaro para ser reusables, declarativos y compartibles. 

Es mejor usar el método anterior que hacerlo directamente en una etiqueta \<script> justo antes de <a-scene> tal y como se hace e la programación tradicional ya que hay que tener en consideración algunos aspectos para que el código se ejecute de forma correcta.


#### Accediendo a las entidades mediante el DOM
Lo bonito del enfoque de A-Frame es que se pueden usar las herramientas tradicionales del DOM para la selección de etiquetas: .querySelector() y .querySelectorAll(). 

>     <html>
>       <a-scene>
>         <a-box id="redBox" class="clickable" color="red"></a-box>
>         <a-sphere class="clickable" color="blue"></a-sphere>
>         <a-box color="green"></a-box>
>         <a-entity light="type: ambient"></a-entity>
>         <a-entity light="type: directional"></a-entity>
>       </a-scene>
>     </html>

##### Con .querySelector()
>     var sceneEl = document.querySelector('a-scene');

**Nota.** Si trabajamos dentro de un componente no es necesario ya que cada elemento de la escena tiene una referencia creada a través del elemento el.

>     AFRAME.registerComponent('foo', {
>       init: function () {
>         console.log(this.el.sceneEl);  // Reference to the scene element.
>       }
>     });

Si una etiqueta A-Frame tiene un ID asignado, podemos usarlo para seleccionarlo:

>     var sceneEl = document.querySelector('a-scene');
>     console.log(sceneEl.querySelector('#redBox'));
>     // <a-box id="redBox" class="clickable" color="red"></a-box>

##### Con .querySelectorAll()
Si queremos recoger un conjunto de elementos usaremos .querySelectorAll() que devuelve un array que podremos recorrer:

>     console.log(sceneEl.querySelectorAll('a-box'));
>     // [
>     //  <a-box id="redBox" class="clickable" color="red"></a-box>,
>     //  <a-box color="green"></a-box>
>     // ]

También podemos selecionar varios elementos según su clase.

>     console.log(sceneEl.querySelectorAll('.clickable'));
>     // [
>     //  <a-box id="redBox" class="clickable" color="red"></a-box>
>     //  <a-sphere class="clickable" color="blue"></a-sphere>
>     // ]

O podemos preguntar por elementos que contengan un atributo.

>     console.log(sceneEl.querySelectorAll('[light]'));
>     // [
>     //  <a-entity light="type: ambient"></a-entity>
>     // <a-entity light="type: directional"></a-entity>
>     // ]

##### Recorriendo Entidades devueltas por .querySelectorAll()
>     var els = sceneEl.querySelectorAll('*');
>     for (var i = 0; i < els.length; i++) {
>       console.log(els[i]);
>     }

###### Una nota sobre rendimiento
Es recomendable no usar las funciones .querySelector y .querySelectorAll en los controladores de evento que se llamen repetidamente y en cada refresco ya que dichas llamadas deben recorrer todo el árbol para devolver lo buscado. En vez, es mejor mantener las entidades a usar en una caché.

>     AFRAME.registerComponent('query-selector-example', {
>      init: function () {
>        this.entities = document.querySelectorAll('.box');
>      },
>        
>        tick: function () {
>          // Don't call query selector in here, query beforehand.
>          for (let i = 0; i < this.entities.length; i++) {
>            // Do something with entities.
>          }
>        }
>      });
>

##### Accediendo a los datos de un conponente con .getAttribute()
--TODO--
We can get the data of components of an entity via .getAttribute. A-Frame augments .getAttribute to return values rather than strings (e.g., returning objects in most cases since components usually consist of multiple properties, or returning an actual boolean for like .getAttribute('visible'). Often, .getAttribute will return the internal data object of the component so do not modify the object directly:

// <a-entity geometry="primitive: sphere; radius: 2"></a-entity>
el.getAttribute('geometry');
// >> {"primitive": "sphere", "radius": 2, ...}

**Retrieving position and scale**
Doing el.getAttribute('position') or el.getAttribute('scale') will return the three.js Object3D position and scale properties which are Vector3s. Keep in mind that modifying these objects will modify the actual entity data.

This is because A-Frame allows us to modify position, rotation, scale, visible at the three.js level, and in order for .getAttribute to return the correct data, A-Frame returns the actual three.js Object3D objects.

This is not true for the .getAttribute('rotation') because A-Frame, for better or worse, uses degrees instead of radians. In such case, a normal JavaScript object with x/y/z properties is returned. The Object3D Euler can be retrieved via el.object3D.rotation if we need to work at a lower level with radians.

##### Modifying the A-Frame Scene Graph
With JavaScript and DOM APIs, we can dynamically add and remove entities as we would with normal HTML elements.

Creating an Entity with .createElement()
To create an entity, we can use document.createElement. This will give us a blank entity:

var el = document.createElement('a-entity');
However, this entity will not be initialized or be a part of the scene until we attach it to our scene.

Adding an Entity with .appendChild()
To add an entity to the DOM, we can use .appendChild(element). Specifically, we want to add it to our scene. We grab the scene, create the entity, and append the entity to our scene.

var sceneEl = document.querySelector('a-scene');
var entityEl = document.createElement('a-entity');
// Do `.setAttribute()`s to initialize the entity.
sceneEl.appendChild(entityEl);
Note that .appendChild() is an asynchronous operation in the browser. Until the entity has finished appending to the DOM, we can’t do many operations on the entity (such as calling .getAttribute()). If we need to query an attribute on an entity that has just been appended, we can listen to the loaded event on the entity, or place logic in an A-Frame component so that it is executed once it is ready:

var sceneEl = document.querySelector('a-scene');

AFRAME.registerComponent('do-something-once-loaded', {
  init: function () {
    // This will be called after the entity has properly attached and loaded.
    console.log('I am ready!');
  }
});

var entityEl = document.createElement('a-entity');
entityEl.setAttribute('do-something-once-loaded', '');
sceneEl.appendChild(entityEl);
Removing an Entity with .removeChild()
To remove an entity from the DOM and thus from the scene, we call .removeChild(element) from the parent element. If we have an entity, we have to ask its parent (parentNode) to remove the entity.

entityEl.parentNode.removeChild(entityEl);

##### Modifying an Entity
A blank entity doesn’t do anything. We can modify the entity by adding components, configuring component properties, and removing components.

Adding a Component with .setAttribute()
To add a component, we can use .setAttribute(componentName, data). Let’s add a geometry component to the entity.

entityEl.setAttribute('geometry', {
  primitive: 'box',
  height: 3,
  width: 1
});
Or adding the community physics component:

entityEl.setAttribute('dynamic-body', {
  shape: 'box',
  mass: 1.5,
  linearDamping: 0.005
});
Unlike a normal HTML .setAttribute(), an entity’s .setAttribute() is improved to take a variety of types of arguments such as objects, or to be able to update a single property of a component. Read more about Entity.setAttribute().

##### Updating a Component with .setAttribute()
To update a component, we also use .setAttribute(). Updating a component takes several forms.

Updating Property of Single-Property Component
Let’s update the property of the position component, a single-property component. We can pass either an object or a string. It is slightly preferred to pass an object so A-Frame doesn’t have to parse the string.

entityEl.setAttribute('position', {x: 1, y: 2, z: -3});
// Read on to see why `entityEl.object3D.position.set(1, 2, -3)` is preferred though.
Updating Single Property of Multi-Property Component
Let’s update a single property of the material component, a multi-property component. We do this by providing the component name, property name, and then property value to .setAttribute():

entityEl.setAttribute('material', 'color', 'red');
Updating Multiple Properties of a Multi-Property Component
Let’s update multiple properties at once of the light component, a multi-property component. We do this by providing the component name and an object of properties to .setAttribute(). We’ll change the light’s color and intensity but leave the type the same:

// <a-entity light="type: directional; color: #CAC; intensity: 0.5"></a-entity>
entityEl.setAttribute('light', {color: '#ACC', intensity: 0.75});
// <a-entity light="type: directional; color: #ACC; intensity: 0.75"></a-entity>
Updating position, rotation, scale, and visible.
As a special case, for better performance, memory, and access to utilities, we recommend modifying position, rotation, scale, and visible directly at the three.js level via the entity’s Object3D rather than via .setAttribute:

// Examples for position.
entityEl.object3D.position.set(1, 2, 3);
entityEl.object3D.position.x += 5;
entityEl.object3D.position.multiplyScalar(5);

// Examples for rotation.
entityEl.object3D.rotation.y = THREE.Math.degToRad(45);
entityEl.object3D.rotation.divideScalar(2);

// Examples for scale.
entityEl.object3D.scale.set(2, 2, 2);
entityEl.object3D.scale.z += 1.5;

// Examples for visible.
entityEl.object3D.visible = false;
entityEl.object3D.visible = true;
This lets us skip over the .setAttribute overhead and instead do simple setting of properties for components that are most commonly updated. Updates at the three.js level will still be reflected when doing for example entityEl.getAttribute('position');.

Replacing Properties of a Multi-Property Component
Let’s replace all the properties of the geometry component, a multi-property component. We do this by providing the component name, an object of properties to .setAttribute(), and a flag that specifies to clobber the existing properties. We’ll replace all of the geometry’s existing properties with new properties:

// <a-entity geometry="primitive: cylinder; height: 4; radius: 2"></a-entity>
entityEl.setAttribute('geometry', {primitive: 'torusKnot', p: 1, q: 3, radiusTubular: 4}, true);
// <a-entity geometry="primitive: torusKnot; p: 1; q: 3; radiusTubular: 4"></a-entity>
##### Removing a Component with .removeAttribute()
To remove or detach a component from an entity, we can use .removeAttribute(componentName). Let’s remove the default wasd-controls from the camera entity:

var cameraEl = document.querySelector('[camera]');
cameraEl.removeAttribute('wasd-controls');

#### Events and Event Listeners
With JavaScript and the DOM, there is an easy way for entities and components to communicate with one another: events and event listeners. Events are a way to send out a signal that other code can pick up and respond to. Read more about browser events.

##### Emitting an Event with .emit()
A-Frame elements provide an easy way to emit custom events with .emit(eventName, eventDetail, bubbles). For example, let’s say we are building a physics component and we want the entity to send out a signal when it has collided with another entity:

entityEl.emit('physicscollided', {collidingEntity: anotherEntityEl}, false);
Then other parts of the code can wait and listen on this event and run code in response. We can pass information and data through the event detail as the second argument. And we can specify whether the event bubbles, meaning that the parent entities will also emit the event. So other parts of the code can register an event listener.

##### Adding an Event Listener with .addEventListener()
Like with normal HTML elements, we can register an event listener with .addEventListener(eventName, function). When the event the listener is registered to is emitted, then the function will be called and handle the event. For example, continuing from the previous example with the physics collision event:

entityEl.addEventListener('physicscollided', function (event) {
  console.log('Entity collided with', event.detail.collidingEntity);
});
When the entity emits the physicscollided event, the function will be called with the event object. Notably in the event object, we have the event detail which contains data and information passed through the event.

##### Removing an Event Listener with .removeEventListener()
Like with normal HTML elements, when we want to remove the event listener, we can use .removeEventListener(eventName, function). We have to pass the same event name and function that the listener was registered with. For example, continuing from the previous example with the physics collision event:

// We have to define this function with a name if we later remove it.
function collisionHandler (event) {
  console.log('Entity collided with', event.detail.collidingEntity);
}

entityEl.addEventListener('physicscollided', collisionHandler);
entityEl.removeEventListener('physicscollided', collisionHandler);
##### Binding Event Listeners
By default, Javascript execution context rules binds this to the global context (window) for any independent function, meaning that these functions won’t have access to the component’s this by default.

In order for the component’s this to be accessible inside an event listener, it must be bound.

There are several ways you can do this:

By using an arrow function to define the event listener. Arrow functions automatically bind this
this.el.addEventListener('physicscollided', (event) => {
    console.log(this.el.id);
});
By defining your event listener within the events object of the component (this will also handling adding and removing the listener automatically)

See the explanation here.

By creating another function, which is the bound version of the function.
this.listeners = {
    clickListener: this.clickListener.bind(this);
}
entityEl.addEventListener('click', this.listeners.clickListener);
#### Caveats
A-Frame entities and primitives are implemented in a way that favours performance such that some HTML APIs may not work as expected. For instance, attribute selectors involving values won’t work and a mutation observer won’t trigger changes when a entity’s component is altered.



---
[Siguiente](ut_5_07.md)
